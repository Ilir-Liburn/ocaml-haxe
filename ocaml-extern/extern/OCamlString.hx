typedef StringT  = String;

@:native("String")
extern class OCamlString {
public static function length(a0:String):Int;
public static function get(a0:String,a1:Int):OCamlChar;
public static function set(a0:haxe.io.Bytes,a1:Int,a2:OCamlChar):Void;
public static function create(a0:Int):haxe.io.Bytes;
public static function unsafe_get(a0:String,a1:Int):OCamlChar;
public static function unsafe_set(a0:haxe.io.Bytes,a1:Int,a2:OCamlChar):Void;
public static function unsafe_blit(a0:String,a1:Int,a2:haxe.io.Bytes,a3:Int,a4:Int):Void;
public static function unsafe_fill(a0:haxe.io.Bytes,a1:Int,a2:Int,a3:OCamlChar):Void;
public static function bts(a0:haxe.io.Bytes):String;
public static function bos(a0:String):haxe.io.Bytes;
public static function make(a0:Int,a1:OCamlChar):String;
public static function init(a0:Int,a1:Int->OCamlChar):String;
public static function copy(a0:String):String;
public static function sub(a0:String,a1:Int,a2:Int):String;
public static function fill(a0:haxe.io.Bytes,a1:Int,a2:Int,a3:OCamlChar):Void;
public static function blit(a0:String,a1:Int,a2:haxe.io.Bytes,a3:Int,a4:Int):Void;
public static function ensure_ge(a0:Int,a1:Int):Int;
public static function sum_lengths(a0:Int,a1:Int,a2:Array<String>):Int;
public static function unsafe_blits(a0:haxe.io.Bytes,a1:Int,a2:String,a3:Int,a4:Array<String>):haxe.io.Bytes;
public static function concat(a0:String,a1:Array<String>):String;
public static function iter(a0:OCamlChar->Dynamic,a1:String):Void;
public static function iteri(a0:Int->OCamlChar->Dynamic,a1:String):Void;
public static function map(a0:OCamlChar->OCamlChar,a1:String):String;
public static function mapi(a0:Int->OCamlChar->OCamlChar,a1:String):String;
public static function is_space(a0:OCamlChar):Bool;
public static function trim(a0:String):String;
public static function escaped(a0:String):String;
public static function index_rec(a0:String,a1:Int,a2:Int,a3:OCamlChar):Int;
public static function index(a0:String,a1:OCamlChar):Int;
public static function index_rec_opt(a0:String,a1:Int,a2:Int,a3:OCamlChar):Dynamic;
public static function index_opt(a0:String,a1:OCamlChar):Dynamic;
public static function index_from(a0:String,a1:Int,a2:OCamlChar):Int;
public static function index_from_opt(a0:String,a1:Int,a2:OCamlChar):Dynamic;
public static function rindex_rec(a0:String,a1:Int,a2:OCamlChar):Int;
public static function rindex(a0:String,a1:OCamlChar):Int;
public static function rindex_from(a0:String,a1:Int,a2:OCamlChar):Int;
public static function rindex_rec_opt(a0:String,a1:Int,a2:OCamlChar):Dynamic;
public static function rindex_opt(a0:String,a1:OCamlChar):Dynamic;
public static function rindex_from_opt(a0:String,a1:Int,a2:OCamlChar):Dynamic;
public static function contains_from(a0:String,a1:Int,a2:OCamlChar):Bool;
public static function contains(a0:String,a1:OCamlChar):Bool;
public static function rcontains_from(a0:String,a1:Int,a2:OCamlChar):Bool;
public static function uppercase_ascii(a0:String):String;
public static function lowercase_ascii(a0:String):String;
public static function capitalize_ascii(a0:String):String;
public static function uncapitalize_ascii(a0:String):String;
public static function split_on_char(a0:OCamlChar,a1:String):Array<String>;
public static function uppercase(a0:String):String;
public static function lowercase(a0:String):String;
public static function capitalize(a0:String):String;
public static function uncapitalize(a0:String):String;
public static function compare(a0:Dynamic,a1:Dynamic):Int;
public static function equal(a0:String,a1:String):Bool;
public static function to_seq(a0:String):Dynamic;
public static function to_seqi(a0:String):Dynamic;
public static function of_seq(a0:Dynamic):String;
}