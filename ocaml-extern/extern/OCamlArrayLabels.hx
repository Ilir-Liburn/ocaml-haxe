@:native("ArrayLabels")
extern class OCamlArrayLabels {
public static function length(a0:Dynamic):Int;
public static function get(a0:Dynamic,a1:Int):Dynamic;
public static function set(a0:Dynamic,a1:Int,a2:Dynamic):Void;
public static function make(a0:Int,a1:Dynamic):Dynamic;
public static function create(a0:Int,a1:Dynamic):Dynamic;
public static function create_float(a0:Int):OCamlArray<Float>;
public static function make_float(a0:Int):OCamlArray<Float>;
public static function init(a0:Int,a1:Int->Dynamic):Dynamic;
public static function make_matrix(a0:Int,a1:Int,a2:Dynamic):Dynamic;
public static function create_matrix(a0:Int,a1:Int,a2:Dynamic):Dynamic;
public static function append(a0:Dynamic,a1:Dynamic):Dynamic;
public static function concat(a0:Dynamic):Dynamic;
public static function sub(a0:Dynamic,a1:Int,a2:Int):Dynamic;
public static function copy(a0:Dynamic):Dynamic;
public static function fill(a0:Dynamic,a1:Int,a2:Int,a3:Dynamic):Void;
public static function blit(a0:Dynamic,a1:Int,a2:Dynamic,a3:Int,a4:Int):Void;
public static function to_list(a0:Dynamic):Dynamic;
public static function of_list(a0:Dynamic):Dynamic;
public static function iter(a0:Dynamic->Void,a1:Dynamic):Void;
public static function iteri(a0:Int->Dynamic->Void,a1:Dynamic):Void;
public static function map(a0:Dynamic->Dynamic,a1:Dynamic):Dynamic;
public static function mapi(a0:Int->Dynamic->Dynamic,a1:Dynamic):Dynamic;
public static function fold_left(a0:Dynamic->Dynamic->Dynamic,a1:Dynamic,a2:Dynamic):Dynamic;
public static function fold_right(a0:Dynamic->Dynamic->Dynamic,a1:Dynamic,a2:Dynamic):Dynamic;
public static function iter2(a0:Dynamic->Dynamic->Void,a1:Dynamic,a2:Dynamic):Void;
public static function map2(a0:Dynamic->Dynamic->Dynamic,a1:Dynamic,a2:Dynamic):Dynamic;
public static function for_all(a0:Dynamic->Bool,a1:Dynamic):Bool;
public static function exists(a0:Dynamic->Bool,a1:Dynamic):Bool;
public static function for_all2(a0:Dynamic->Dynamic->Bool,a1:Dynamic,a2:Dynamic):Bool;
public static function exists2(a0:Dynamic->Dynamic->Bool,a1:Dynamic,a2:Dynamic):Bool;
public static function mem(a0:Dynamic,a1:Dynamic):Bool;
public static function memq(a0:Dynamic,a1:Dynamic):Bool;
public static function sort(a0:Dynamic->Dynamic->Int,a1:Dynamic):Void;
public static function stable_sort(a0:Dynamic->Dynamic->Int,a1:Dynamic):Void;
public static function fast_sort(a0:Dynamic->Dynamic->Int,a1:Dynamic):Void;
public static function to_seq(a0:Dynamic):OCaml'aSeq.T;
public static function to_seqi(a0:Dynamic):OCamlfunSeq.T;
public static function of_seq(a0:OCaml'aSeq.T):Dynamic;
public static function unsafe_get(a0:Dynamic,a1:Int):Dynamic;
public static function unsafe_set(a0:Dynamic,a1:Int,a2:Dynamic):Void;
}