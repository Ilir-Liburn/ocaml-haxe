@:native("List")
extern class OCamlList {
public static function length_aux(a0:Int,a1:Dynamic):Int;
public static function length(a0:Dynamic):Int;
public static function cons(a0:Dynamic,a1:Dynamic):Dynamic;
public static function hd(a0:Dynamic):Dynamic;
public static function tl(a0:Dynamic):Dynamic;
public static function nth(a0:Dynamic,a1:Int):Dynamic;
public static function nth_opt(a0:Dynamic,a1:Int):Dynamic;
public static function append(a0:Dynamic,a1:Dynamic):Dynamic;
public static function rev_append(a0:Dynamic,a1:Dynamic):Dynamic;
public static function rev(a0:Dynamic):Dynamic;
public static function init_tailrec_aux(a0:Dynamic,a1:Int,a2:Int,a3:Int->Dynamic):Dynamic;
public static function init_aux(a0:Int,a1:Int,a2:Int->Dynamic):Dynamic;
public static var rev_init_threshold:Int;
public static function init(a0:Int,a1:Int->Dynamic):Dynamic;
public static function flatten(a0:Dynamic):Dynamic;
public static function concat(a0:Dynamic):Dynamic;
public static function map(a0:Dynamic->Dynamic,a1:Dynamic):Dynamic;
public static function mapi(a0:Int->Dynamic->Dynamic,a1:Dynamic):Dynamic;
public static function rev_map(a0:Dynamic->Dynamic,a1:Dynamic):Dynamic;
public static function iter(a0:Dynamic->Dynamic,a1:Dynamic):Void;
public static function iteri(a0:Int->Dynamic->Dynamic,a1:Dynamic):Void;
public static function fold_left(a0:Dynamic->Dynamic->Dynamic,a1:Dynamic,a2:Dynamic):Dynamic;
public static function fold_right(a0:Dynamic->Dynamic->Dynamic,a1:Dynamic,a2:Dynamic):Dynamic;
public static function map2(a0:Dynamic->Dynamic->Dynamic,a1:Dynamic,a2:Dynamic):Dynamic;
public static function rev_map2(a0:Dynamic->Dynamic->Dynamic,a1:Dynamic,a2:Dynamic):Dynamic;
public static function iter2(a0:Dynamic->Dynamic->Dynamic,a1:Dynamic,a2:Dynamic):Void;
public static function fold_left2(a0:Dynamic->Dynamic->Dynamic->Dynamic,a1:Dynamic,a2:Dynamic,a3:Dynamic):Dynamic;
public static function fold_right2(a0:Dynamic->Dynamic->Dynamic->Dynamic,a1:Dynamic,a2:Dynamic,a3:Dynamic):Dynamic;
public static function for_all(a0:Dynamic->Bool,a1:Dynamic):Bool;
public static function exists(a0:Dynamic->Bool,a1:Dynamic):Bool;
public static function for_all2(a0:Dynamic->Dynamic->Bool,a1:Dynamic,a2:Dynamic):Bool;
public static function exists2(a0:Dynamic->Dynamic->Bool,a1:Dynamic,a2:Dynamic):Bool;
public static function mem(a0:Dynamic,a1:Dynamic):Bool;
public static function memq(a0:Dynamic,a1:Dynamic):Bool;
public static function assoc(a0:Dynamic,a1:Dynamic):Dynamic;
public static function assoc_opt(a0:Dynamic,a1:Dynamic):Dynamic;
public static function assq(a0:Dynamic,a1:Dynamic):Dynamic;
public static function assq_opt(a0:Dynamic,a1:Dynamic):Dynamic;
public static function mem_assoc(a0:Dynamic,a1:Dynamic):Bool;
public static function mem_assq(a0:Dynamic,a1:Dynamic):Bool;
public static function remove_assoc(a0:Dynamic):Dynamic;
public static function remove_assq(a0:Dynamic):Dynamic;
public static function find(a0:Dynamic->Bool,a1:Dynamic):Dynamic;
public static function find_opt(a0:Dynamic->Bool,a1:Dynamic):Dynamic;
public static function find_map(a0:Dynamic->Dynamic,a1:Dynamic):Dynamic;
public static function find_all(a0:Dynamic->Bool,a1:Dynamic):Dynamic;
public static function filter(a0:Dynamic->Bool,a1:Dynamic):Dynamic;
public static function filteri(a0:Int->Dynamic->Bool,a1:Dynamic):Dynamic;
public static function filter_map(a0:Dynamic->Dynamic,a1:Dynamic):Dynamic;
public static function concat_map(a0:Dynamic->Dynamic,a1:Dynamic):Dynamic;
public static function fold_left_map(a0:Dynamic->Dynamic->Dynamic,a1:Dynamic,a2:Dynamic):Dynamic;
public static function partition(a0:Dynamic->Bool,a1:Dynamic):Dynamic;
public static function partition_map(a0:Dynamic->Dynamic,a1:Dynamic):Dynamic;
public static function split(a0:Dynamic):Dynamic;
public static function combine(a0:Dynamic,a1:Dynamic):Dynamic;
public static function merge(a0:Dynamic->Dynamic->Int,a1:Dynamic,a2:Dynamic):Dynamic;
public static function stable_sort(a0:Dynamic->Dynamic->Int,a1:Dynamic):Dynamic;
public static function sort(a0:Dynamic->Dynamic->Int,a1:Dynamic):Dynamic;
public static function fast_sort(a0:Dynamic->Dynamic->Int,a1:Dynamic):Dynamic;
public static function sort_uniq(a0:Dynamic->Dynamic->Int,a1:Dynamic):Dynamic;
public static function compare_lengths(a0:Dynamic,a1:Dynamic):Int;
public static function compare_length_with(a0:Dynamic,a1:Int):Int;
public static function equal(a0:Dynamic->Dynamic->Bool,a1:Dynamic,a2:Dynamic):Bool;
public static function compare(a0:Dynamic->Dynamic->Int,a1:Dynamic,a2:Dynamic):Int;
public static function to_seq(a0:Dynamic):Dynamic;
public static function of_seq(a0:Dynamic):Dynamic;
}